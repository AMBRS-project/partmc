
Fix binned output with n_coag for grid_centers and grid_edges. While
for plotting a 2d plot it's good to have grid_edges be integers, it's
also pretty amiguous, and messes up things like sum_above("n_coag", 4)
to mean 4 or more consituent particles.

Change error messages in inout.f90 to use die_msg().

We shouldn't really need both aero_binned_t and aero_dist_t. Actually
aero_dist_t should go away, so that we can generate exact samplings
for particle-based methods from the original continuous distribution.

Change Makefile to not use FFLAGS as the thing to set, but rather use
DEF_FFLAGS or something, and include FFLAGS without settting it. Also
print out all settings before starting compilation.

Change gas conc from ppb to mole proportion.

Get a better bessel function so that we can compute the exact golovin
solution for larger arguments.

Add implicit, adaptive timestepping for the condensation ODE solver.

Implement a better poisson distribution generator. We should probably
generate a poisson sample per-bin, rather than doing a total sample
and then using a slow sampling to pick samples one-by-one.

Add separate del_t for mosaic, coag, and cond. Check on input that
t_output, etc are multiples of del_t so that the n_time header
information is actually correct.

aero_binned is really storing #/dln(m)/m^3 or something?

Pass full particle data to the kernel_*() functions so that we can do
proper density-dependent brownian kernels. Requires a separate
max_kernel_*() function for each one.

Use mpi_sizeof() to get the sizes for reals, logicals, etc. There are
also functions called MPI_Sizeof1DR8 for a 1D array of real*8,
etc. What about 2D arrays, is it correct to treat them as 1D as we do
at present with mpi_pack?

Change gas mixing to be by diffusion, rather than allreduce, also env.

Add env%day_of_year (days since jan 1) and env%time_of_day (secs since
midnight) and shift info on start day, start time, etc to
env_data. Change mosaic_timestep() to just read time/day info out of
env directly. Update this info in env_data_update_state().

Allow times to be input as 1d, 34m, etc. No unit implies seconds.

Add H2O as a gas species and just track it as a regular gas, getting
rid of relative humidity in env. add a relative_humidity(env,
gas_data, gas_state) function.

Memory allocation policy should be that all functions must be called
with an already allocated structure. That is, always call type_alloc()
before calling anything else. The functions will call type_free() if
they need to before writing new data, or will take care of
(de)allocation internally. Currently at least the spec_read functions
don't free before setting new values and should be fixed.

Fix local variable sections to always be all integers, then all reals,
etc, with only one "integer ::" and then & for the rest of the lines.

Change spec_read_aero_data to spec_read_aero_data_filename and pass in
the name, and similar spec_read_*.

Add allow_halve to control that separately.

Add parameter to composition processing for type: vol, mass or mole.

Use switch/case rather than elseif chains.

Fix calling convention for aerosol_optical from mosaic.f90. Do we do
it every timestep, or just when needed, or what? What about
coagulation? Does this come in the right order?

Change aero_dists to actually store the distribution parameters,
rather than generating the discretized version immediately. This will
allow us to sample log-normal and others exactly.

Maybe generate initial number of particles from a Poisson
distribution, rather than just using the mean as we do now?

Use doxygen to generate docs. Fortran supported as of version 1.5.4.

Fix MPI so it works again.

Change state files to be in NetCDF format.

Change gas_state_add(), gas_state_sub(), gas_state_scale(), etc, to
just be gas_state_daxpy(), and for other structures.

Get rid of PMC_EVEREST in mpi.f90.

In output_processed.f90 change ensure_nc_var_env_state() to have a
name argument which will be process_spec%name. In
urban_plume/process.dat we currently list env to have "name env" which
should be "name env_state" to match current behavior. We should check
that the names specified in process.dat do not conflict with each
other or with the dimension names.

rename frac_type to comp_type for consistency

non-particle data:
  env data: height, temp, RH, etc
  gas data: concentrations(40)
all particles:
  functions of particles:
    time
    radius
    dry_radius
    composition ratio(a_spec, b_spec, frac_type)
    n_orig
    critical supersat
    scattering cross section
    single scattering albedo
    mass(with_species, except_species)
    volume(with_species, except_species)
    moles(with_species, except_species)
    number density

bin_particles(quantity, axes, where)

bin_particles(quantity = mass(with_species = ["BC"]),
              axis_list = [axis(radius(),
        			n_bin = 160, min = 1e-15, max = 1e-10,
				log_scale = True),
		           axis(comp(a_spec = ["BC"],
                                     b_spec = ["OC", "NO3", "SO4"],
                                     frac_type = "volume"),
				n_bin = 100, min = 0, max = 1,
				log_scale = False)],
              where_list = [select(time(), only = 3600),
                            select(n_orig(), above = 3),
	                    select(crit_ss(), below = 0.34)])

bin_array = zeros(160, 100)
for p in particles:
    if (time(p) == 3600) and (n_orig(p) <= 3) and (crit_ss(p) <= 0.34):
       x_bin = find_bin(radius(p), min = 1e-15, max = 1e-10, n_bin = 160)
       y_bin = find_bin(comp(p, a_spec = ["BC"], b_spec = ["OC", "NO3", "SO4"],
                             frac_type = "volume"),
                        min = 0, max = 1, n_bin = 100, log_scale = True),
       bin_array[x_bin, y_bin] += mass(p, with_species = ["BC"])



bin_array = bin_array(x = log_axis(min = 1e-15, max = 1e-10, n_bin = 160),
	              y = log_axis(min = 0, max = 1, n_bin = 100))
for p in particles:
    if (time(p) == 3600) and (n_orig(p) <= 3) and (crit_ss(p) <= 0.34):
       bin_array.add(x = radius(p),
       		     y = comp(p, a_spec = ["BC"], b_spec = ["OC", "NO3", "SO4"],
                              frac_type = "volume"),
                     quantity = mass(p, with_species = ["BC"]))
plot(bin_array.to_list())



radius_axis = log_axis(min = 1e-15, max = 1e-10, n_bin = 160)
comp_axis = log_axis(min = 0, max = 1, n_bin = 100)
bin_array = zeros(radius_axis.n_bin, comp_axis.n_bin)
for p in particles:
    if (time(p) == 3600) and (n_orig(p) <= 3) and (crit_ss(p) <= 0.34):
       x_bin = radius_axis.find(radius(p))
       y_bin = comp_axis.find(comp(p, a_spec = ["BC"],
                                   b_spec = ["OC", "NO3", "SO4"],
                                   frac_type = "volume"))
       bin_array[x_bin, y_bin] += mass(p, with_species = ["BC"])
make_list(bin_array, axes = [radius_axis, comp_axis])



bin_particles(quantity = mass(with_species = ["NO3"]),
              axis_list = [axis(time(), type = pointwise)])

bin_hash = {}
for p in particles:
    x_bin = time(p)
    bin_hash[x_bin] += mass(p, with_species = ["NO3"])

bin_particles(quantity = mass(),
              axes = [axis(radius(),
                           min = 1e-15, max = 1e-10, n_bin = 160)],
              where = [select(time(), equal = 3600),
                       select(comp(a_spec = ["BC"],
                                   b_spec = ["OC", "NO3", "SO4"],
                                   frac_type = "volume"),
                              above = 0.8, below = 0.9)])

bin_array = zeros(160)
for p in particles:
    if (time(p) == 3600):
       c = comp(p, a_spec = ["BC"], b_spec = ["OC", "NO3", "SO4"])
       if (c > 0.8) and (c < 0.9):
          x_bin = find_bin(radius(p), min = 1e-15, max = 1e-10, n_bin = 160,
                           log_scale = True)
	  bin_array[x_bin] += mass(p)
