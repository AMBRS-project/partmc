#!/usr/bin/env python
# Copyright (C) 2007 Matthew West
# Licensed under the GNU General Public License version 2 or (at your
# option) any later version. See the file COPYING for details.

import os, sys, re
from optparse import OptionParser
sys.path.insert(0, os.path.expanduser("~/.python"))
from pyx import *

file_magic = {
    "# histogram matrix\n": "hist_matrix",
    "# histogram totals\n": "hist_total",
    "# aerosol binned\n": "aero_binned",
    "# aerosol time history\n": "aero_history",
    "# gas time history\n": "gas_history",
    "# environment time history\n": "env_history",
    }

hist_col_type_names = {
    "_n_orig_part": ["number of component particles", ""],
    "_comp": ["mixing state", "\\%"],
    "_kappa": ["critical supersaturation", "\\%"],
    }

env_field_names = {
    'temp': ['temperature', '(K)', 2],
    'rh': ['relative humidity', "", "($3*100)"],
    'press': ['pressure', '(kPa)', "($4/1e3)"],
    'height': ['height', '(m)', 5],
    }

time_unit_names = {
    'day': '$1/86400',
    'hour': '$1/3600',
    'min': '$1/60',
    'sec': '1',
    }

aerosol_species_titles = {
    "SO4_a": "SO$_4$",
    "NO3_a": "NO$_3$",
    "Cl_a": "Cl",
    "NH4_a": "NH$_4$",
    "MSA_a": "MSA",
    "ARO1_a": "ARO1",
    "ARO2_a": "ARO2",
    "ALK1_a": "ALK1",
    "OLE1_a": "OLE1",
    "API1_a": "API1",
    "API2_a": "API2",
    "LIM1_a": "LIM1",
    "LIM2_a": "LIM2",
    "CO3_a": "CO$_3$",
    "Na_a": "Na",
    "Ca_a": "Ca",
    "OIN_a": "OIN",
    "OC_a": "Organic carbon",
    "BC_a": "Black carbon",
    "H2O": "H$_2$O",
    }

gas_species_titles = {
    "H2SO4": "H$_2$SO$_4$",
    "HNO3": "HNO$_3$",
    "HCl": "HC$\ell$",
    "NH3": "NH$_3$",
    "NO2": "NO$_2$",
    "NO3": "NO$_3$",
    "N2O5": "N$_2$O$_5$",
    "HNO4": "HNO$_4$",
    "O3": "O$_3$",
    "O1D": "O$_1$D",
    "O3P": "O$_3$P",
    "HO2": "HO$_2$",
    "H2O2": "H$_2$O$_2$",
    "SO2": "SO$_2$",
    "CH4": "CH$_4$",
    "C2H6": "C$_2$H$_6$",
    "CH3O2": "CH$_3$O$_2$",
    "CH3OH": "CH$_3$OH",
    "CH3OOH": "CH$_3$OOH",
    "C2O3": "C$_2$O$_3$",
    "CH3SO2H": "CH$_3$SO$_2$H",
    "CH3SCH2OO": "CH$_3$SCH$_2$OO",
    "CH3SO2": "CH$_3$SO$_2$",
    "CH3SO3": "CH$_3$SO$_3$",
    "CH3SO2OO": "CH$_3$SO$_2$OO",
    "CH3SO2CH2OO": "CH$_3$SO$_2$CH$_2$OO",
    }

class listpalette(color.palette):

    def __init__(self, colorlist):
        color.palette.__init__(self)
        self.colorclass = colorlist[0][1].__class__
        self.colorlist = colorlist

    def getcolor(self, param):
	for i in range(len(self.colorlist)):
	    if self.colorlist[i][0] >= param:
		break
	else:
	    raise ValueError
	if i == 0:
	    i = 1
	# list[i-1] < param < list[i]
	alpha = (param - self.colorlist[i-1][0]) \
	    / (self.colorlist[i][0] - self.colorlist[i-1][0])
        colordict = {}
        for key in self.colorlist[0][1].color.keys():
            colordict[key] = alpha * self.colorlist[i][1].color[key] \
		+ (1 - alpha) * self.colorlist[i-1][1].color[key]
        return self.colorclass(**colordict)

def process_args():
    usage = "usage: %prog [options] <datafile>"
    parser = OptionParser(usage = usage)
    parser.add_option("-u", "--unit", default = "num",
		      help = "Unit to plot with. Must be 'num', 'vol', " \
		      + "'mass' or 'mole'. [default: %default]")
    parser.add_option("-i", "--index", type = "int", action = "append",
		      default = [0],
		      help = "Index to plot, starting from 0. Can be given " \
		      + "multiple times. [default: %default]")
    parser.add_option("-s", "--species", action = "append",
		      default = ["total"],
		      help = "Species to plot, either as a number or name. " \
		      + "Can also be 'total' to plot total quantities. Can " \
		      + "be given multiple times. [default: %default]")
    parser.add_option("-e", "--env-field", action = "append",
		      default = ["temp"],
		      help = "Environment quantities to plot. Must be " \
		      + "'temp', 'rh', 'press', or 'height'. Can be given " \
		      + "multiple times. [default: %default]")
    parser.add_option("-t", "--time-unit", default = "hour",
		      help = "Time unit to plot with. Must be 'day', " \
		      + "'hour', 'min' or 'sec'. [default: %default]")
    parser.add_option("-o", "--output", metavar = "FILE",
		      help = "Filename to write output to. [default: " \
		      + "<datafile>.pdf]")
    parser.add_option("--xmin", type = "float", help = "Minimum x axis value.")
    parser.add_option("--xmax", type = "float", help = "Maximum x axis value.")
    parser.add_option("--ymin", type = "float", help = "Minimum y axis value.")
    parser.add_option("--ymax", type = "float", help = "Maximum y axis value.")
    parser.add_option("--zmin", type = "float", help = "Minimum z axis value.")
    parser.add_option("--zmax", type = "float", help = "Maximum z axis value.")

    (options, args) = parser.parse_args()
    if len(args) < 1:
	parser.error("must give at least one datafile argument")
    data_filenames = args
    return (data_filenames, parser)

def get_species_names(data_filename, type):
    f = open(data_filename)
    if not f:
	print "ERROR: unable to open %s" % data_filename
	sys.exit(1)
    if type == "aero_binned":
	f.readline()
	f.readline()
	f.readline()
	f.readline()
    if type == "aero_history":
	f.readline()
	f.readline()
    f.readline()
    f.readline()
    header = f.readline()
    f.close()
    if header[0] != '#':
	print "ERROR: header does not start with #: %s" % header
	sys.exit(1)
    cols = header[1:].split()
    if (type == "aero_history") or (type == "aero_binned"):
	species = ["total"]
	spec_re = re.compile("^\d+-VL/(.+)$")
	for col in cols:
	    match = spec_re.search(col)
	    if match:
		species.append(match.group(1))
    elif type == "gas_history":
	species = ["total"] + cols[1:]
    else:
	print "ERROR: unknown type: %s" % type
	sys.exit(1)
    return species

def normalize_species(species, species_names):
    species_nums = []
    error = False
    n = 0
    for s in species:
	try:
	    n = int(s)
	    if (n < 0) or (n >= len(species_names)):
		error = True
		print "ERROR: species number out of range: %d" % n
	except ValueError:
	    found = False
	    for i in range(len(species_names)):
		if s.lower() == species_names[i].lower():
		    found = True
		    n = i
		    break
	    if not found:
		error = True
		print "ERROR: unknown species: %s" % s
	species_nums.append(n)
    if error:
	sys.exit(1)
    species_nums.sort()
    return species_nums

def normalize_times(times):
    times_nums = []
    error = False
    n = 0
    for i in times:
	try:
	    n = int(i)
	    if (n < 0):
		error = True
		print "ERROR: index number out of range: %d" % n
	except ValueError:
	    error = True
	    print "ERROR: unknown index: %s" % i
	times_nums.append(n)
    if error:
	sys.exit(1)
    times_nums.sort()
    return times_nums

def normalize_env_fields(env_fields):
    norm_env_fields = []
    error = False
    for e in env_fields:
	if e.lower() not in env_field_names.keys():
	    error = True
	    print "ERROR: unknown environment field: %s" % env_fields[0]
	norm_env_fields.append(e.lower())
    if error:
	sys.exit(1)
    return norm_env_fields

def normalize_unit(unit):
    norm_unit = unit.lower()
    if norm_unit not in ['num', 'vol', 'mass', 'mole']:
	print "ERROR: unknown unit: %s" % unit
	sys.exit(1)
    return norm_unit

def print_species_table(species_nums, species_names):
    col = 0
    for i in species_nums:
	print ("%5d %-15s" % (i, species_names[i])),
	col += 1
	if col == 3:
	    print
	    col = 0
    if col != 0:
	print

def plot_aero_binned(data_filename, out_filename, unit,
		     species_nums, species_names, indices, parser):
    # read data
    f = open(data_filename)
    if unit == "num":
	if species_nums != [0]:
	    print "ERROR: for number density can only plot total aerosol"
	    sys.exit(1)
	ytitle = 'number density (\#/m$^3$)'
    elif unit == "vol":
	ytitle = 'volume density (m$^3$/m$^3$)'
	offset = 2
    elif unit == "mass":
	ytitle = 'mass density (kg/m$^3$)'
	offset = len(species_names) + 1
    elif unit == "mole":
	ytitle = 'molar density (moles/m^3)'
	offset = 2 * len(species_names)
    else:
	print "ERROR: unknown unit: %s" % unit
	sys.exit(1)
    comment_re = re.compile("^#")
    blank_re = re.compile("^\s*$")
    data_list = []
    line = f.readline()
    while line:
	while comment_re.search(line):
	    line = f.readline()
	data = []
	last_v = 0
	last_r = 0
	last_last_v = 0
	while not blank_re.search(line):
	    els = line.split()
	    r = float(els[0])
	    if species_nums == [0]:
		if unit == "num":
		    v = float(els[1])
		else:
		    v = sum([float(els[i + offset - 1])
			     for i in range(len(species_names))])
	    else:
		v = float(els[species_nums[0] + offset - 1])
	    if v > 0:
		data.append([r, v])
	    else:
		if (last_v != 0) and (last_last_v == 0):
		    data.append([last_r, last_v * 0.5])
		data.append([r, None])
	    line = f.readline()
	    last_last_v = last_v
	    last_v = v
	    last_r = r
	if (last_v != 0) and (last_last_v == 0):
	    data.append([last_r, last_v * 0.5])
	data_list.append(data)
	line = f.readline()
	line = f.readline()
    g = graph.graphxy(
	width = 10,
	x = graph.axis.log(
	    title = "radius (m)",
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	y = graph.axis.log(
	    title = ytitle,
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	key = graph.key.key(pos = "tr"))
    spec = species_names[species_nums[0]]
    if spec in aerosol_species_titles.keys():
	spec_title = aerosol_species_titles[spec]
    else:
	spec_title = spec
    plots = []
    for i in indices:
	plots.append(graph.data.list(data_list[i], x = 1, y = 2,
				     title = "%s aerosol (index %d)"
				     % (spec_title, i)))
    g.plot(plots,
	   styles = [graph.style.line(lineattrs = [style.linestyle.solid,
						   color.palette.Rainbow])])
    g.writePDFfile(out_filename)

def plot_aero_history(data_filename, out_filename, unit,
		      species_nums, species_names, parser):
    if unit == "num":
	ytitle = 'number density (\#/m$^3$)'
    elif unit == "vol":
	ytitle = 'volume density (m$^3$/m$^3$)'
	offset = 2
    elif unit == "mass":
	ytitle = 'mass density (kg/m$^3$)'
	offset = len(species_names) + 1
    elif unit == "mole":
	ytitle = 'molar density (moles/m^3)'
	offset = 2 * len(species_names)
    else:
	print "ERROR: unknown unit: %s" % unit
	sys.exit(1)
    g = graph.graphxy(
	width = 10,
	x = graph.axis.linear(
	    min = parser.values.xmin,
	    max = parser.values.xmax,
	    title = "time (hours)",
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	y = graph.axis.linear(
	    min = parser.values.ymin,
	    max = parser.values.ymax,
	    title = ytitle,
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	key = graph.key.key(pos = "tr"))
    plots = []
    if unit == "num":
	if species_nums != [0]:
	    print "ERROR: for number density can only plot total aerosol"
	    sys.exit(1)
	plots.append(graph.data.file(data_filename, x = "$1/3600", y = 2,
				     title = "total aerosol"))
    else:
	for i in species_nums:
	    spec = species_names[i]
	    if spec in aerosol_species_titles.keys():
		title = aerosol_species_titles[spec]
	    else:
		title = spec
	    plots.append(graph.data.file(data_filename,
					 x = "$1/3600", y = i + offset,
					 title = "%s (aerosol)" % title))
    g.plot(plots,
	   styles = [graph.style.line(lineattrs = [style.linestyle.solid,
						   color.palette.Rainbow])])
    g.writePDFfile(out_filename)

def plot_gas_history(data_filename, out_filename, species_nums,
		     species_names, parser):
    g = graph.graphxy(
	width = 10,
	x = graph.axis.linear(
	    min = parser.values.xmin,
	    max = parser.values.xmax,
	    title = "time (hours)",
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	y = graph.axis.linear(
	    min = parser.values.ymin,
	    max = parser.values.ymax,
	    title = "concentration (ppb)",
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	key = graph.key.key(pos = "tr"))
    plots = []
    for i in species_nums:
	if i == 0:
	    print "ERROR: cannot plot total gas concentration yet"
	    sys.exit(1)
	spec = species_names[i]
	if spec in gas_species_titles.keys():
	    title = gas_species_titles[spec]
	else:
	    title = spec
	plots.append(graph.data.file(data_filename, x = "$1/3600", y = i + 1,
				     title = "%s (gas)" % title))
    g.plot(plots,
	   styles = [graph.style.line(lineattrs = [style.linestyle.solid,
						   color.palette.Rainbow])])
    g.writePDFfile(out_filename)

def plot_env(data_filename, out_filename, env_fields, parser):
    yargs = {}
    for i, e in enumerate(env_fields):
	if e not in env_field_names.keys():
	    print "ERROR: unknown environment field: %s" % e
	    sys.exit(1)
	if i > 0:
	    yname = "y%d" % (i + 1)
	else:
	    yname = "y"
	if e == 'rh':
	    texter = graph.axis.texter.decimal(suffix="\\%")
	else:
	    texter = graph.axis.texter.decimal()
	yargs[yname] = graph.axis.linear(title = "%s %s"
					 % (env_field_names[e][0],
					    env_field_names[e][1]),
					 texter = texter)
    g = graph.graphxy(
	width = 10,
	x = graph.axis.linear(
	    min = parser.values.xmin,
	    max = parser.values.xmax,
	    title = "time (hours)",
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	key = graph.key.key(pos = "tr"),
	**yargs)
    plots = []
    for i, e in enumerate(env_fields):
	if i > 0:
	    yname = "y%d" % (i + 1)
	else:
	    yname = "y"
	yargs = {yname: env_field_names[e][2]}
	plots.append(graph.data.file(data_filename,
				     x = "$1/3600",
				     title = env_field_names[e][0],
				     **yargs))
    g.plot(plots,
	   styles = [graph.style.line(lineattrs = [style.linestyle.solid,
						   color.palette.Rainbow])])
    g.writePDFfile(out_filename)

def plot_hist_matrix(data_filename, out_filename, parser):
    f = open(data_filename)
    f.readline()
    f.readline()

    line = f.readline()
    match = re.compile("^# columns are (.+) bins$").search(line)
    if not match:
	print "ERROR: unable to determine column type"
	sys.exit(1)
    col_type = match.group(1)
    if col_type not in hist_col_type_names.keys():
	print "ERROR: unknown column type: %s" % col_type
	sys.exit(1)
    col_type_name = hist_col_type_names[col_type][0]
    col_type_suffix = hist_col_type_names[col_type][1]
    
    line = f.readline()
    match = re.compile("^# entries are (.+)$").search(line)
    if not match:
	print "ERROR: unable to determine entry type"
	sys.exit(1)
    unit = match.group(1)
    
    f.readline()
    f.readline()
    f.readline()
    f.readline()
    line = f.readline()
    elements = line.split()
    c = [float(i) for i in elements[1:]]
    if col_type in ["_comp", "_kappa"]:
	c = [x * 100 for x in c]
    
    d = []
    first_line = True
    max_val = 0
    for line in f:
	if line == "\n":
	    continue
	elements = line.split()
	r = float(elements[0])
	if not first_line:
	    for i, v in enumerate(data):
		if v > max_val:
		    max_val = v
		d.append([last_r, r, c[i], c[i+1], v])
	data = [float(i) for i in elements[1:-1]]
	n = len(data)
	if first_line:
	    first_line = False
	    min_r = r
	max_r = r
	last_r = r
    f.close()
    scaled_d = []
    ep = 1e-4 * (c[-1] - c[0])
    if parser.values.zmax:
	max_val = parser.values.zmax
    min_val = 0
    if parser.values.zmin:
	min_val = parser.values.zmin
    min_val = float(min_val)
    max_val = float(max_val)
    for [x1, x2, y1, y2, v] in d:
	if v > 0:
	    scaled_v = (float(v) - min_val) / (max_val - min_val)
	    scaled_v = min(scaled_v, 1)
	    scaled_v = max(scaled_v, 0)
	    scaled_d.append([x1 * (1 - ep), x2 * (1 + ep),
			     y1 * (1 - ep), y2 * (1 + ep),
			     scaled_v])
    if parser.values.xmin:
	min_r = parser.values.xmin
    if parser.values.xmax:
	max_r = parser.values.xmax
    cmin = c[0]
    cmax = c[-1]
    if parser.values.ymin:
	cmin = parser.values.ymin
    if parser.values.ymax:
	cmax = parser.values.ymax
    if col_type == "_kappa":
	g = graph.graphxy(
	    width = 10,
	    x = graph.axis.log(
		min = min_r, max = max_r,
		title = 'radius (m)'),
	    y = graph.axis.log(
		min = cmin, max = cmax,
		title = col_type_name,
		texter = graph.axis.texter.decimal(suffix = col_type_suffix)))
    else:
	g = graph.graphxy(
	    width = 10,
	    x = graph.axis.log(
		min = min_r, max = max_r,
		title = 'radius (m)'),
	    y = graph.axis.linear(
		min = cmin, max = cmax,
		title = col_type_name,
		texter = graph.axis.texter.decimal(suffix = col_type_suffix)))
    pal = listpalette([[0, color.rgb(0, 0, 1)],
		       [0.3, color.rgb(0, 1, 1)],
		       [0.5, color.rgb(0, 1, 0)],
		       [0.7, color.rgb(1, 1, 0)],
		       [1, color.rgb(1, 0, 0)]])
    g.plot(graph.data.list(scaled_d, xmin = 1, xmax = 2,
			   ymin = 3, ymax = 4, color = 5),
	   [graph.style.rect(pal)])
    colorbar_steps = 1000
    color_d = []
    for i in range(colorbar_steps):
	x0 = float(i) / float(colorbar_steps)
	xh = (float(i) + 0.5) / float(colorbar_steps)
	x1 = float(i + 1) / float(colorbar_steps)
	v0 = x0 * (max_val - min_val) + min_val
	v1 = x1 * (max_val - min_val) + min_val
	color_d.append([0, 1, v0, v1, xh])
    g2 = g.insert(graph.graphxy(width = 0.5, height = 4,
				xpos = g.width + 1, ypos = 1,
				x = graph.axis.linear(min = 0, max = 1,
						      parter = None),
				y2 = graph.axis.linear(min = min_val,
						       max = max_val,
						       title = unit)))
    g2.plot(graph.data.list(color_d, xmin = 1, xmax = 2,
			    ymin = 3, ymax = 4, color = 5),
	    [graph.style.rect(pal)])
    g2.dolayout()
    g2.dobackground()
    g2.dodata()
    g2.doaxes()
    g.writePDFfile(out_filename)

def plot_hist_total(data_filename, out_filename, parser):
    f = open(data_filename)
    f.readline()

    line = f.readline()
    match = re.compile("^# quantities are (.+)$").search(line)
    if not match:
	print "ERROR: unable to determine entry type"
	sys.exit(1)
    unit = match.group(1)
    
    line = f.readline()
    match = re.compile("^# steps are (.+)$").search(line)
    if not match:
	print "ERROR: unable to determine step type"
	sys.exit(1)
    col_type = match.group(1)
    if col_type not in hist_col_type_names.keys():
	print "ERROR: unknown column type: %s" % col_type
	sys.exit(1)
    col_type_name = hist_col_type_names[col_type][0]
    col_type_suffix = hist_col_type_names[col_type][1]
    
    f.readline()
    f.readline()
    
    q = []
    c = []
    first_line = True
    for line in f:
	elements = line.split()
	c.append(float(elements[0]))
	if not first_line:
	    q.append(last_v)
	last_v = float(elements[1])
	first_line = False
    f.close()
    if col_type in ["_comp", "_kappa"]:
	c = [x * 100 for x in c]
    d = [[q[i], c[i], c[i+1]] for i in range(len(q))]

    if col_type == "_kappa":
	yaxis = graph.axis.log(
	    min = parser.values.ymin,
	    max = parser.values.ymax,
	    title = col_type_name,
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])]),
	    texter = graph.axis.texter.decimal(suffix = col_type_suffix))
    else:
	yaxis = graph.axis.linear(
	    min = parser.values.ymin,
	    max = parser.values.ymax,
	    title = col_type_name,
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])]),
	    texter = graph.axis.texter.decimal(suffix = col_type_suffix))
    g = graph.graphxy(
	width = 10,
	x = graph.axis.linear(
	    min = parser.values.xmin,
	    max = parser.values.xmax,
	    title = unit,
	    painter = graph.axis.painter.regular(
		gridattrs = [attr.changelist([style.linestyle.dotted, None])])),
	y = yaxis)
    g.plot(graph.data.list(d, x = 1, ymin = 2, ymax = 3, title = None),
	   [graph.style.histogram(autohistogramaxisindex = 1,
				  autohistogrampointpos = 0,
				  fillable = True,
				  steps = True,
				  lineattrs=[color.palette.Rainbow,
					     deco.stroked([color.rgb.blue]),
					     deco.filled([color.rgb.blue])])])
    g.writePDFfile(out_filename)

def get_type(data_filename):
    f = open(data_filename)
    line = f.readline()
    f.close()
    if line not in file_magic.keys():
	print "ERROR: file type not plottable: %s" % data_filename
	sys.exit(1)
    return file_magic[line]

def plot_file(data_filename, out_filename, parser):
    type = get_type(data_filename)
    indices = parser.values.index
    if len(indices) > 1:
	indices = indices[1:]
    env_fields = parser.values.env_field
    if len(env_fields) > 1:
	env_fields = env_fields[1:]
    species = parser.values.species
    if len(species) > 1:
	species = species[1:]
    indices = normalize_times(indices)
    env_fields = normalize_env_fields(env_fields)
    unit = normalize_unit(parser.values.unit)
    if type in ["aero_binned", "aero_history", "gas_history"]:
	species_names = get_species_names(data_filename, type)
	print "Available species:"
	print_species_table(range(len(species_names)), species_names)
	species_nums = normalize_species(species, species_names)
	print "Selected species:"
	print_species_table(species_nums, species_names)
    if type == "env_history":
	print "Selected environment fields:"
	for e in env_fields:
	    print "           %s" % env_field_names[e][0]
    if type == "aero_binned":
	plot_aero_binned(data_filename, out_filename, unit,
			 species_nums, species_names, indices, parser)
    elif type == "aero_history":
	plot_aero_history(data_filename, out_filename, unit,
			  species_nums, species_names, parser)
    elif type == "gas_history":
	plot_gas_history(data_filename, out_filename, species_nums,
			 species_names, parser)
    elif type == "env_history":
	plot_env(data_filename, out_filename, env_fields, parser)
    elif type == "hist_matrix":
	plot_hist_matrix(data_filename, out_filename, parser)
    elif type == "hist_total":
	plot_hist_total(data_filename, out_filename, parser)
    else:
	print "ERROR: unknown type: %s" % type
	sys.exit(1)

def main():
    (data_filenames, parser) = process_args()
    if parser.values.output and len(data_filenames) > 1:
	    print "ERROR: cannot specify output filename with multiple " \
		+ "data filenames"
	    sys.exit(1)
    for data_filename in data_filenames:
	if parser.values.output:
	    out_filename = parser.values.output
	else:
	    out_filename = data_filename
	(out_filename, ext) = os.path.splitext(out_filename)
	plot_file(data_filename, out_filename, parser)
    
if __name__ == "__main__":
    main()
